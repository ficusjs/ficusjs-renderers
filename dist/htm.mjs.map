{"version":3,"file":"htm.mjs","sources":["../node_modules/htm/src/index.mjs","../node_modules/htm/src/build.mjs","../src/jsx-dom.mjs","../src/htm.mjs"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MINI } from './constants.mjs';\nimport { build, evaluate } from './build.mjs';\n\nconst CACHES = new Map();\n\nconst regular = function(statics) {\n\tlet tmp = CACHES.get(this);\n\tif (!tmp) {\n\t\ttmp = new Map();\n\t\tCACHES.set(this, tmp);\n\t}\n\ttmp = evaluate(this, tmp.get(statics) || (tmp.set(statics, tmp = build(statics)), tmp), arguments, []);\n\treturn tmp.length > 1 ? tmp : tmp[0];\n};\n\nexport default MINI ? build : regular;\n","import { MINI } from './constants.mjs';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst TAG_SET = 3;\nconst PROPS_ASSIGN = 4;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n// \ttreeify(\n//\t\tbuild`<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//\t\t[X, Y, Z]\n//\t)\n// returns:\n// \t{\n// \t\ttag: 'div',\n//\t\tprops: [ { href: [\"1\", X] }, Y ],\n// \t\tchildren: [ { tag: Z, props: [], children: [] } ]\n// \t}\nexport const treeify = (built, fields) => {\n\tconst _treeify = built => {\n\t\tlet tag = '';\n\t\tlet currentProps = null;\n\t\tconst props = [];\n\t\tconst children = [];\n\n\t\tfor (let i = 1; i < built.length; i++) {\n\t\t\tconst type = built[i++];\n\t\t\tconst value = built[i] ? fields[built[i++]-1] : built[++i];\n\n\t\t\tif (type === TAG_SET) {\n\t\t\t\ttag = value;\n\t\t\t}\n\t\t\telse if (type === PROPS_ASSIGN) {\n\t\t\t\tprops.push(value);\n\t\t\t\tcurrentProps = null;\n\t\t\t}\n\t\t\telse if (type === PROP_SET) {\n\t\t\t\tif (!currentProps) {\n\t\t\t\t\tcurrentProps = Object.create(null);\n\t\t\t\t\tprops.push(currentProps);\n\t\t\t\t}\n\t\t\t\tcurrentProps[built[++i]] = [value];\n\t\t\t}\n\t\t\telse if (type === PROP_APPEND) {\n\t\t\t\tcurrentProps[built[++i]].push(value);\n\t\t\t}\n\t\t\telse if (type === CHILD_RECURSE) {\n\t\t\t\tchildren.push(_treeify(value));\n\t\t\t}\n\t\t\telse if (type === CHILD_APPEND) {\n\t\t\t\tchildren.push(value);\n\t\t\t}\n\t\t}\n\n\t\treturn { tag, props, children };\n\t};\n\tconst { children } = _treeify(built);\n\treturn children.length > 1 ? children : children[0];\n};\n\nexport const evaluate = (h, built, fields, args) => {\n\tlet tmp;\n\n\t// `build()` used the first element of the operation list as\n\t// temporary workspace. Now that `build()` is done we can use\n\t// that space to track whether the current element is \"dynamic\"\n\t// (i.e. it or any of its descendants depend on dynamic values).\n\tbuilt[0] = 0;\n\n\tfor (let i = 1; i < built.length; i++) {\n\t\tconst type = built[i++];\n\n\t\t// Set `built[0]`'s appropriate bits if this element depends on a dynamic value.\n\t\tconst value = built[i] ? ((built[0] |= type ? 1 : 2), fields[built[i++]]) : built[++i];\n\n\t\tif (type === TAG_SET) {\n\t\t\targs[0] = value;\n\t\t}\n\t\telse if (type === PROPS_ASSIGN) {\n\t\t\targs[1] = Object.assign(args[1] || {}, value);\n\t\t}\n\t\telse if (type === PROP_SET) {\n\t\t\t(args[1] = args[1] || {})[built[++i]] = value;\n\t\t}\n\t\telse if (type === PROP_APPEND) {\n\t\t\targs[1][built[++i]] += (value + '');\n\t\t}\n\t\telse if (type) { // type === CHILD_RECURSE\n\t\t\t// Set the operation list (including the staticness bits) as\n\t\t\t// `this` for the `h` call.\n\t\t\ttmp = h.apply(value, evaluate(h, value, fields, ['', null]));\n\t\t\targs.push(tmp);\n\n\t\t\tif (value[0]) {\n\t\t\t\t// Set the 2nd lowest bit it the child element is dynamic.\n\t\t\t\tbuilt[0] |= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Rewrite the operation list in-place if the child element is static.\n\t\t\t\t// The currently evaluated piece `CHILD_RECURSE, 0, [...]` becomes\n\t\t\t\t// `CHILD_APPEND, 0, tmp`.\n\t\t\t\t// Essentially the operation list gets optimized for potential future\n\t\t\t\t// re-evaluations.\n\t\t\t\tbuilt[i-2] = CHILD_APPEND;\n\t\t\t\tbuilt[i] = tmp;\n\t\t\t}\n\t\t}\n\t\telse { // type === CHILD_APPEND\n\t\t\targs.push(value);\n\t\t}\n\t}\n\n\treturn args;\n};\n\nexport const build = function(statics) {\n\tconst fields = arguments;\n\tconst h = this;\n\n\tlet mode = MODE_TEXT;\n\tlet buffer = '';\n\tlet quote = '';\n\tlet current = [0];\n\tlet char, propName;\n\n\tconst commit = field => {\n\t\tif (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent.push(field ? fields[field] : buffer);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(CHILD_APPEND, field, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_TAGNAME && (field || buffer)) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[1] = field ? fields[field] : buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(TAG_SET, field, buffer);\n\t\t\t}\n\t\t\tmode = MODE_WHITESPACE;\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n\t\t\tif (MINI) {\n\t\t\t\tcurrent[2] = Object.assign(current[2] || {}, fields[field]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROPS_ASSIGN, field, 0);\n\t\t\t}\n\t\t}\n\t\telse if (mode === MODE_WHITESPACE && buffer && !field) {\n\t\t\tif (MINI) {\n\t\t\t\t(current[2] = current[2] || {})[buffer] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent.push(PROP_SET, 0, true, buffer);\n\t\t\t}\n\t\t}\n\t\telse if (mode >= MODE_PROP_SET) {\n\t\t\tif (MINI) {\n\t\t\t\tif (mode === MODE_PROP_SET) {\n\t\t\t\t\t(current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\telse if (field || buffer) {\n\t\t\t\t\tcurrent[2][propName] += field ? buffer + fields[field] : buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (buffer || (!field && mode === MODE_PROP_SET)) {\n\t\t\t\t\tcurrent.push(mode, 0, buffer, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t\tif (field) {\n\t\t\t\t\tcurrent.push(mode, field, 0, propName);\n\t\t\t\t\tmode = MODE_PROP_APPEND;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuffer = '';\n\t};\n\n\tfor (let i=0; i<statics.length; i++) {\n\t\tif (i) {\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t\tcommit(i);\n\t\t}\n\n\t\tfor (let j=0; j<statics[i].length;j++) {\n\t\t\tchar = statics[i][j];\n\n\t\t\tif (mode === MODE_TEXT) {\n\t\t\t\tif (char === '<') {\n\t\t\t\t\t// commit buffer\n\t\t\t\t\tcommit();\n\t\t\t\t\tif (MINI) {\n\t\t\t\t\t\tcurrent = [current, '', null];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcurrent = [current];\n\t\t\t\t\t}\n\t\t\t\t\tmode = MODE_TAGNAME;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode === MODE_COMMENT) {\n\t\t\t\t// Ignore everything until the last three characters are '-', '-' and '>'\n\t\t\t\tif (buffer === '--' && char === '>') {\n\t\t\t\t\tmode = MODE_TEXT;\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer = char + buffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (quote) {\n\t\t\t\tif (char === quote) {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (char === '\"' || char === \"'\") {\n\t\t\t\tquote = char;\n\t\t\t}\n\t\t\telse if (char === '>') {\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_TEXT;\n\t\t\t}\n\t\t\telse if (!mode) {\n\t\t\t\t// Ignore everything until the tag ends\n\t\t\t}\n\t\t\telse if (char === '=') {\n\t\t\t\tmode = MODE_PROP_SET;\n\t\t\t\tpropName = buffer;\n\t\t\t\tbuffer = '';\n\t\t\t}\n\t\t\telse if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n\t\t\t\tcommit();\n\t\t\t\tif (mode === MODE_TAGNAME) {\n\t\t\t\t\tcurrent = current[0];\n\t\t\t\t}\n\t\t\t\tmode = current;\n\t\t\t\tif (MINI) {\n\t\t\t\t\t(current = current[0]).push(h.apply(null, mode.slice(1)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t(current = current[0]).push(CHILD_RECURSE, 0, mode);\n\t\t\t\t}\n\t\t\t\tmode = MODE_SLASH;\n\t\t\t}\n\t\t\telse if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n\t\t\t\t// <a disabled>\n\t\t\t\tcommit();\n\t\t\t\tmode = MODE_WHITESPACE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer += char;\n\t\t\t}\n\n\t\t\tif (mode === MODE_TAGNAME && buffer === '!--') {\n\t\t\t\tmode = MODE_COMMENT;\n\t\t\t\tcurrent = current[0];\n\t\t\t}\n\t\t}\n\t}\n\tcommit();\n\n\tif (MINI) {\n\t\treturn current.length > 2 ? current.slice(1) : current[1];\n\t}\n\treturn current;\n};\n","/* global Node */\nconst flatten = arr => arr.flat(1)\n\nconst h = (tag, attrs, ...children) => {\n  let elm = null\n  let isSvg = false\n  if (['svg', 'use', 'symbol', 'path', 'g', 'defs', 'title'].indexOf(tag) > -1) {\n    elm = document.createElementNS('http://www.w3.org/2000/svg', tag)\n    isSvg = true\n  } else {\n    elm = document.createElement(tag)\n  }\n  for (const key in attrs) {\n    if (key.slice(0, 2) === 'on') {\n      const evtName = key.slice(2)\n      const cb = attrs[key]\n      if (cb == null) continue // we can use null or undefined to suppress\n      elm.addEventListener(evtName, cb)\n    } else if (['disabled', 'selected', 'checked'].indexOf(key) > -1) {\n      if (attrs[key]) {\n        elm.setAttribute(key, key)\n      }\n    } else if (key === 'xlinkHref' && isSvg) {\n      if (attrs[key]) {\n        elm.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', attrs[key])\n      }\n    } else if (key === 'href' && isSvg) {\n      if (attrs[key]) {\n        elm.setAttributeNS('http://www.w3.org/1999/xlink', 'href', attrs[key])\n      }\n    } else {\n      if (attrs[key] == null) continue // Don't set undefined or null attributes\n      elm.setAttribute(key, attrs[key])\n    }\n  }\n  if (children.length === 0) {\n    return elm\n  }\n  const fc = flatten(children)\n  fc.forEach(child => {\n    if (child instanceof Node) {\n      elm.appendChild(child)\n    } else {\n      elm.appendChild(document.createTextNode(child))\n    }\n  })\n  if (tag == null) {\n    return elm.children\n  }\n  return elm\n}\n\nconst fragment = null\n\nexport { h, fragment }\n","import htm from 'htm/src/index.mjs'\nimport { h } from './jsx-dom.mjs'\n\nconst html = htm.bind(h)\n\nfunction renderer (what, where) {\n  // remove any existing elements\n  while (where.firstChild) where.removeChild(where.firstChild)\n\n  // add the element to the DOM\n  Array.isArray(what) ? what.forEach(w => where.appendChild(w)) : where.appendChild(what)\n}\n\nexport { html, renderer }\n"],"names":["htm","statics","fields","arguments","h","this","char","propName","mode","buffer","quote","current","commit","field","replace","push","Object","assign","i","length","j","apply","slice","html","bind","tag","attrs","children","elm","isSvg","indexOf","document","createElementNS","createElement","key","evtName","cb","addEventListener","setAttribute","setAttributeNS","flat","forEach","child","Node","appendChild","createTextNode","renderer","what","where","firstChild","removeChild","Array","isArray","w"],"mappings":"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"}